## Patience → Strikes → Lose (MVP)

### Цель

Реализовать **MVP-логику провала смены** через **страйки**:

* **3 страйка** (конфигурируемо) → **провал смены**.
* **Patience=0 блокирует только свой service slot** (второй слот продолжает работать).
* Страйк считается **только в момент перехода patience: >0 → 0**.

---

## Зафиксированные решения (НЕ обсуждать, не менять)

1. **Patience=0 (B1):** клиент **остаётся в своём слоте**, слот считается “заблокированным” этим клиентом, **второй слот работает**.
2. **Lose-condition:** смена проваливается при **3 событиях** “patience достиг 0” (страйки).
3. **Страйк засчитывается только при переходе >0 → 0** (если клиент пришёл уже с 0 — не считается).
4. **Смена не должна софтлокаться:** клиента с 0 **можно дообслужить** до завершения его checkout и он **уходит** (освобождает слот), но страйк уже засчитан.

---

## Ограничения по архитектуре (чтобы Codex не «поехал»)

* **Не размазывать правила по UI-адаптерам.** UI только отображает, правила живут в домене/сервисах смены.
* **Не завязывать домен на ноды/сцены.** Домен оперирует моделями/событиями, сцена лишь прокидывает события и слушает результаты.
* **Одна точка истины** для: текущих страйков, порога страйков, статуса смены (running/failed/success).
* **Минимум сайд-эффектов**: изменения состояния смены и счётчиков — атомарно и детерминированно.

---

## Что нужно сначала прочитать в проекте (обязательно)

Codex должен найти (по поиску в репозитории) и понять:

1. Где сейчас **тикается patience** (логика уменьшения).
2. Где сейчас обрабатывается **patience <= 0** (есть ли немедленный fail/конец смены).
3. Где хранится состояние смены/рана (условный `ShiftService`, `RunManager`, `WorkdeskScene` и т.п.).
4. Как сейчас считается “конец смены” и каким способом делается переход в fail/success (сигналы/события/методы).
5. Как UI получает данные (HUD snapshot/сигналы/адаптеры) — чтобы добавить отображение страйков без вмешательства в правила.

---

## Требуемая логика (поведение системы)

### 1) Учёт страйков

* Ввести счётчик `strikes_current`.
* Ввести порог `strikes_limit` (в MVP дефолт 3, но **обязательно через конфиг/настройку**).
* Ввести механизм “уникальности события”:

  * Страйк инкрементится **только один раз на конкретного клиента в конкретной фазе ожидания**, при переходе `patience > 0 → 0`.
  * Повторные тики на нуле не должны добавлять новые страйки.

### 2) Переход клиента в patience=0

При достижении нуля:

* Клиент **остаётся** в своём service slot.
* Слот считается **занятым** (его нельзя заменить новым клиентом).
* Patience далее **не убывает** (остается 0).
* Второй слот работает как обычно (никаких глобальных блокировок).

### 3) Lose-condition

* Как только `strikes_current >= strikes_limit`:

  * смена переводится в состояние **FAILED** (или эквивалент).
  * запускается уже существующий механизм завершения смены (не городить второй параллельный).
* Если в проекте есть debug-флаги, они не должны “ломать” возможность тестировать эту ветку (по крайней мере в обычном режиме).

---

## Изменения в данных/моделях (высокоуровнево)

Codex должен:

* Добавить поле(я) в модель состояния смены/рана: `strikes_current`, `strikes_limit`.
* Добавить лёгкое доменное событие/метод типа “зарегистрировать patience_zero для клиента” (название не важно).
* Обновить/расширить снапшот для HUD (если он есть), чтобы UI мог показать:

  * `strikes_current / strikes_limit`
  * опционально: “в этом слоте клиент на 0” (если UI уже это показывает — не дублировать).

---

## Acceptance Criteria (что должно быть истинно после мержа)

1. Если у клиента в слоте A patience падает до 0:

   * слот A остаётся занятым этим клиентом,
   * слот B продолжает принимать/обслуживать клиентов,
   * `strikes_current` увеличивается на 1 ровно один раз.
2. Если тот же клиент продолжает висеть с 0 ещё 10 секунд:

   * `strikes_current` **не меняется**.
3. Если клиент пришёл уже с 0 (или выставлен в 0 внешней логикой без перехода >0→0):

   * страйк **не добавляется**.
4. На третьем страйке:

   * смена завершается через единый механизм fail (без дублей/рассинхрона),
   * состояние смены однозначно “failed”.
5. UI (если есть HUD) отображает страйки корректно и обновляется при их изменении.

---

## Тесты (минимальный набор)

Codex должен добавить/обновить тесты в существующей тестовой инфраструктуре проекта (какая есть), чтобы проверить:

* **Strike increments only on transition**.
* **No double counting**.
* **Second slot continues** при patience=0 на первом.
* **Fail at 3 strikes**.

Если в проекте нет нормальных unit-тестов, допускается “интеграционный тест” на уровне сцены/сервиса (в пределах того, как у вас принято), но с чёткими проверками состояний и без ручной отладки.

---

## Не делать в этой задаче (чтобы не расползлось)

* Не менять экономику, чаевые, штрафы.
* Не менять правила Zombie/Vampire/Ghost.
* Не трогать формулу win-condition по N_checkin/N_checkout.
* Не перепридумывать очередь/спавнер — только обеспечить, что слот с 0 считается занятым.

---

## Definition of Done (коротко)

* Страйки считаются правильно.
* 3 страйка = fail смены.
* Patience=0 блокирует только свой слот.
* UI показывает страйки (если есть HUD).
* Есть тесты, которые краснеют на старом поведении и зеленеют на новом.
