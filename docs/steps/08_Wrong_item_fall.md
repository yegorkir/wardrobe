# Task: Wrong item → падение на пол + штраф patience (MVP)

## Контекст (что считаем правдой)

* Ситуация: игрок пытается выдать предмет клиенту на **check-out**.
* Если предмет **не принадлежит** этому клиенту → это `WRONG_ITEM`.
* Последствия `WRONG_ITEM`:

  1. предмет **выталкивается/падает на пол** (как обычное падение: участвует в общей системе урона/качества);
  2. клиент получает **штраф patience**, величина зависит от **типа клиента** (числа могут быть в конфиге/данных, но сами числа в этой задаче не фиксируем);
  3. событие не должно давать двойной эффект при повторной обработке (идемпотентность).

## Цель итерации

Добавить бизнес-логику и события так, чтобы UI только отображал падение и VFX, а все решения “что произошло” принимались в application/use-case.

## Non-goals (что НЕ делаем в этой задаче)

* Не меняем базовую систему drag-and-drop целиком.
* Не добавляем новую экономику/чаевые/штрафы денег.
* Не внедряем новые архетипы или новые типы порчи.
* Не меняем правила win/lose смены (кроме того, что эта логика не должна ломать их).
* Не делаем “правильный” баланс чисел штрафа — только проводим штраф через существующие/новые data поля.

## Архитектурные требования (guardrails)

1. **UI не решает**: не выбирает пол, не списывает patience, не “дёргает” доменную модель напрямую.
2. Последствие должно быть **детерминированным** и воспроизводимым (floor выбирается одним и тем же способом при одинаковых условиях).
3. Штраф patience применяется **только если** предмет реально “снят” со стойки (см. идемпотентность).

---

## План работ (пошагово, маленькими кусками)

### Step 1 — Нормализовать событие reject (контракт)

* Зафиксировать единый `reason_code = WRONG_ITEM`.
* В reject-событие (или структуру контекста) добавить поля, без которых дальше нельзя:

  * `client_instance_id`, `client_slot_id`
  * `desk_slot_id`
  * `item_instance_id`
  * `client_phase` (важно отличать check-in/check-out)
  * `event_id` или иной ключ идемпотентности/трассировки

**DoD Step 1:** по логам/дампу видно, что при wrong item контекст заполнен полностью.

---

### Step 2 — Policy “последствия reject” (чистое правило)

* Реализовать policy уровня application: по `(reason_code, client_phase)` вернуть:

  * `drop_to_floor = true/false`
  * `apply_patience_penalty = true/false`
  * `penalty_reason = WRONG_ITEM` (без чисел)

**DoD Step 2:** unit-тесты policy на минимум 4 кейса:
wrong-item checkout / wrong-item checkin / not-wrong checkout / not-wrong checkin.

---

### Step 3 — Атомарный “pop предмета со стойки” (идемпотентность)

* Добавить единую операцию “попнуть предмет из desk_slot”:

  * Первый вызов успешен и возвращает `item_instance_id`.
  * Повторный вызов для того же слота даёт `success=false`.

**DoD Step 3:** тест/проверка: двойной pop не дублирует эффекты, состояние стойки консистентно.

---

### Step 4 — Use-case: обработка WRONG_ITEM на check-out

* В use-case обработке reject:

  * вызвать policy
  * если надо применить последствия:

    1. попытаться атомарно pop предмет со стойки
    2. **только если pop успешен**:

       * применить штраф patience (через одну точку входа в patience-систему)
       * отправить предмет на пол (через сервис выбора пола)
       * эмитнуть событие(я) для UI

**DoD Step 4:** повторная обработка того же reject не приводит к повторному штрафу и второму “дропу”.

---

### Step 5 — FloorResolver (сервис мира)

* Вынести выбор “какой floor_surface_id” в отдельный сервис/интерфейс.
* Требования:

  * детерминированность
  * понятный fallback (если не нашли “специальный пол” → дефолтный пол зоны)

**DoD Step 5:** тесты/проверки на минимум 2 сценария (нормальный + fallback).

---

### Step 6 — Событие для UI: ITEM_DROPPED

* Эмитить `EVENT_ITEM_DROPPED` (или аналог) с payload:

  * `item_instance_id`
  * `from_location = desk_slot_id`
  * `to_location = floor_surface_id`
  * `cause = WRONG_ITEM`
  * (опционально) `client_instance_id` для VFX

**DoD Step 6:** UI может проиграть падение, не вычисляя ничего сам.

---

### Step 7 — UI: отображение падения и reject VFX

* UI слушает `EVENT_ITEM_DROPPED` и проигрывает:

  * выталкивание/падение
  * reject VFX
* UI **не** меняет доменную модель.

**DoD Step 7:** отключение UI не ломает симуляцию (модель всё равно переводит предмет “на пол”).

---

### Step 8 — Интеграционная проверка “падение = обычный урон качества”

* Убедиться, что падение, инициированное wrong-item, проходит через общий путь “падение → потенциальный урон качества”.
* Здесь важно не добавлять отдельные исключения “wrong падение не портит”.

**DoD Step 8:** сценарий: wrong item → предмет на полу → урон качества возможен по общей системе.

---

## Acceptance Criteria (итоговые)

1. Wrong item на check-out:

   * предмет **снимается со стойки** (атомарно),
   * **падает на пол** (через FloorResolver),
   * клиент получает **patience penalty** (число из данных/типа),
   * падение учитывается как обычное (может снижать качество).
2. `patience=0` блокирует только слот клиента — эта задача не должна ломать это поведение.
3. Идемпотентность:

   * повтор обработки reject не даёт повторного штрафа и второго падения.

## Мини-набор тестов/проверок

* Unit: policy
* Unit/Integration: atomic pop
* Integration: wrong-item flow end-to-end (desk → pop → drop → patience)
* Smoke: UI получил `ITEM_DROPPED` и проиграл анимацию
