# Task: Iteration 4.1 - Finish shift win counters

## Context

- Shift completion must depend only on throughput counters: `checkin_done` and `checkout_done` vs thresholds.
- Current code already has counters and a win policy, but wiring can still be driven by scene/UI events or legacy completion paths.
- We must ensure the win condition is purely domain-driven and not blocked by desk/floor cleanliness, remaining items, or visible clients.

## Goal

Make the shift end only when both counters reach configured thresholds:

- `checkin_done >= N_checkin`
- `checkout_done >= N_checkout`

Counters increment exactly once per qualifying domain event:

- `checkin_done` increments when a client takes a ticket (ticket transfer confirmed).
- `checkout_done` increments when a client receives all items and leaves (handoff complete + exit confirmed).

Shift completion must ignore clutter/visibility and be deterministic.

## Non-goals

- No UI-driven completion logic.
- No refactors unrelated to counters/win rules.
- No new game balance or economy changes.
- No changes to fail rules (strikes, patience, etc.).

---

## Architecture guardrails

1. **Domain events vs engine events**
   - Domain reacts only to `CheckinCompleted` / `CheckoutCompleted` events.
   - Scene/animation signals are not win conditions; they only decide when to emit domain events.

2. **Dedup is a domain invariant**
   - Domain must prevent double-counting (by `client_id` or a checkout token).
   - No reliance on UI debouncing.

3. **ShiftCompleted is domain state**
   - Domain sets status to `success` and emits `ShiftWon`.
   - UI/scene reacts (summary screen, stopping spawners), but domain does not clean the scene.

4. **Config boundary**
   - Config is read in infrastructure; thresholds are passed into the app/domain (do not parse config in domain).

5. **No Node coupling in domain**
   - Domain code must not access scene tree or node paths.

---

## Required behavior

- Counters are monotonic and increment once per qualifying event.
- Shift completes immediately when both thresholds are met (`>=`), regardless of leftover tickets/items or visible clients.
- Win logic must be idempotent (no duplicate win events).

---

## Plan (small, testable steps)

### Step 1 - Audit current sources and paths

- Identify where thresholds come from (config or wave setup).
- Identify where `register_checkin_completed` and `register_checkout_completed` are called.
- Identify any alternative shift-complete paths (manual end, wave fail, scene cleanup, etc.).
- Confirm which domain event maps to "client left scene" for checkout completion.

**DoD Step 1**: list of concrete files/functions for thresholds, counter events, and completion triggers.

---

### Step 2 - Define and enforce the counter contract (domain/app)

- Ensure `RunState` or app layer owns:
  - counters,
  - thresholds,
  - dedup sets (client ids or tokens).
- Add explicit domain event entry points if missing (e.g., `register_checkin_completed(client_id)`), with dedup checks.
- Ensure checkin is triggered by `EVENT_CLIENT_PHASE_CHANGED` (DROP_OFF -> PICK_UP) and checkout by `EVENT_CLIENT_COMPLETED` (treated as "client left scene").

**DoD Step 2**: counters increment once per unique client/token; repeated events are ignored.

---

### Step 3 - Align threshold source of truth

- Ensure thresholds are injected into the app layer from `content/waves` (single source of truth).
- Remove any UI-side constants or duplicated thresholds.

**DoD Step 3**: a single configuration path sets `target_checkin` and `target_checkout`.

---

### Step 4 - Make win condition purely counter-based

- Keep win policy dependent only on counters and targets.
- Ensure no other conditions (desk cleanliness, active nodes, or wave cleanup) block `ShiftWon`.

**DoD Step 4**: given counters reach thresholds, `ShiftWon` fires even with leftover scene objects.

---

### Step 5 - Wire event emission from scene/adapters

- Ensure check-in and checkout domain events are emitted only when the domain event is true:
  - check-in: ticket transfer done (phase change to PICK_UP),
  - checkout: `EVENT_CLIENT_COMPLETED` (treated as "client left scene").
- Thread `client_id` through the adapter bridge to support domain dedup.
- Avoid tying counters to animation or node deletion directly.

**DoD Step 5**: event emission points map 1:1 to domain events and include `client_id` for dedup.

---

### Step 6 - Shift end behavior

- Confirm `ShiftWon` triggers summary flow and does not require manual `end_shift` gating.
- Ensure fail paths remain intact and still take precedence when applicable.

**DoD Step 6**: shift summary shows `SHIFT_WON` when thresholds are met; fail logic unaffected.

---

### Step 7 - Tests and verification

- Unit tests:
  - thresholds are applied correctly,
  - checkin/checkout increment once per client,
  - win triggers only when both are met.
- Lightweight integration test or scenario script:
  - counters reach thresholds while clutter remains.

**DoD Step 7**: tests cover counter increments, dedup, and win rule; no softlocks.

---

## Acceptance criteria

- Thresholds are configured from a single source of truth.
- `checkin_done` increments once per successful ticket-take.
- `checkout_done` increments once per completed handoff + exit.
- Shift ends immediately when both thresholds are met (`>=`).
- Shift end is not blocked by desk/floor clutter or visible clients.
- No new softlocks or UI-driven logic.
- Minimal code changes outside the shift flow.

---

## Debug hooks (optional)

- `SHIFT_COUNTERS thresholds=(N_checkin, N_checkout) done=(checkin_done, checkout_done)`
- `EV_CHECKIN_DONE client=<id> total=<checkin_done>`
- `EV_CHECKOUT_DONE client=<id> total=<checkout_done>`
- `EV_SHIFT_COMPLETED reason=thresholds_reached`

---

## Rollback plan

- If tests fail, revert win condition changes first.
- Keep counter instrumentation (safe) while rolling back completion gating.
- Re-apply increment/dedup and win gating separately.
