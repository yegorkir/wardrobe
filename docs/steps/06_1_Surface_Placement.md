# Step 6.1 — Surface placement (полки) + Floor (упал — подними)

## Цель
Добавить новый тип хранения: **полка/поверхность**, где предметы размещаются строго по позиции игрока (без автоподгона).
Если размещение невалидно — предмет падает на пол и остаётся подбираемым.

## Почему отдельный шаг
Это новая механика размещения (DnD + правила размещения + хранение позиций).
Она ортогональна “эффектам” (Vampire/Zombie/Ghost) и должна быть стабилизирована отдельно, чтобы Step 6.2 не пришлось переписывать.

---

## UX (фиксируем)
### Place to shelf
- Игрок тянет предмет → отпускает кнопку над полкой.
- Предмет “падает” вниз на полку (tween).
- Никаких snap/auto-fit/first-fit.
- Если размещение не получилось → предмет падает на **пол** и остаётся интерактивным (игрок должен поднять и попробовать снова).

### Pick from shelf / floor
- Наводим курсор на конкретный предмет → начинаем drag этого предмета.
- Никаких меню.

---

## Модель данных (логические юниты с дробями, fixed-point)
### Единицы
- Используем логические юниты для баланса.
- Для непрерывного размещения используем fixed-point:
    - `UNIT_SCALE = 1000`
    - координаты и размеры на полке храним в sub-units (`*_su`) как int.

### Shelf
- `capacity_units` (например 10.0) → `capacity_su = round(capacity_units * UNIT_SCALE)`
- размещения на полке — интервалы:
    - `placement = { item_id, x_su, size_su }`
    - интервал занимает `[x_su, x_su + size_su)`.

### Pixel → sub-unit mapping (anti-precision footgun)
- У каждой полки есть `shelf_length_px` (ширина в локальных координатах).
- На drop берём **целочисленный пиксель** левого края: `x_px_i = floor(x_px)` (фиксируем этот вариант).
- Конвертация:
    - `x_su = floor(x_px_i * capacity_su / shelf_length_px)`
      Это убирает ситуацию “45.00001” → округлилось не туда.

---

## Правила валидности размещения (STRICT)
Пусть новый интервал `[x, x+size)`:
- bounds:
    - `0 <= x`
    - `x + size <= capacity_su`
- overlap:
    - для каждого существующего `[a,b)` запрещено пересечение:
        - overlap есть если `x < b && (x+size) > a`

Если невалидно → drop-fail → предмет падает на пол.

---

## Hook vs Shelf
- `HOOK`: single-occupancy (1 предмет), требует `HANG`.
- `SHELF`: multi-occupancy по интервалам, требует `LAY`.

(BOTH предметы) = предмет поддерживает `HANG|LAY` (битмаска), без отдельного “типа”.

---

## PlacementBehavior seam (на будущее, MVP только default)
Чтобы не получить спагетти позже:
- логика “можно ли положить” живёт в pure объекте поведения.
  MVP:
- только `DefaultPlacementBehavior`:
    - HOOK: `HANG` + слот пуст
    - SHELF: `LAY` + STRICT валидность интервала

Запрет:
- никакой “утиной типизации” через `has_method()` по нодам.

---

## FloorZone (упал — подними)
- Если drop на полку невалиден:
    - предмет удаляется из “руки”
    - появляется на FloorZone в точке падения
    - остаётся pickable
    - визуально tween до Y пола
- Anti-footgun “куча на полу”:
    - при падении добавлять небольшой `x_offset` (рандомный или детерминированный), чтобы предметы не падали строго в одну точку,
    - `x_offset` должен быть ограничен шириной FloorZone (clamp), чтобы не терять предметы за краем.

### Landing events (Step 6.1 refactor)
- Пол/поверхности не используют `one_way_collision`.
- “Вверх через пол” реализуется через collision-профили предмета:
  - RISE: коллизии с FLOOR выключены.
  - FALL: коллизии только с FLOOR.
- FALL использует отдельный physics layer (transfer-fall), который не виден обычным предметам; floor сканирует этот слой.
- В момент стабилизации на поверхности эмитится `EVENT_ITEM_LANDED` с payload (item_id, item_kind, surface_kind, cause, impact).
- App слой возвращает `LandingOutcome`, UI применяет эффекты (например, BOUNCE/BREAK).

---

## Z-order и pickability (anti-footguns)
- Для полки и пола нужен стабильный порядок отрисовки:
    - предпочтение: включить y-sort на контейнере (ShelfContainer/FloorContainer),
    - или выставлять z_index по Y (например `z_index = int(global_position.y)`).
- Pick-test идёт по предметам (Area2D):
    - коллизии должны быть “плотными” по спрайту (не огромными),
    - при пересечении нескольких Area2D должен подбираться **верхний** предмет (topmost).

---

## Non-goals
- Хрупкость/разбитие/штрафы за падение (позже).
- Реальная физика/стэкинг/гравитация.
- Изменения доменной модели клиентов/волн.

---

## DoD
- Есть хотя бы одна полка-поверхность, принимающая несколько предметов.
- Размещение строгое: нет автоподгона.
- Невалидный drop → предмет лежит на полу и его можно поднять.
- Pick работает “по предмету под курсором” и выбирает topmost при overlap.
- Визуально порядок предметов на полке/полу не хаотичен (y-sort/z_index).
- Нет регрессий Step 4/5 DnD.
