# Technical Design Document (Godot)

## 0. Цель документа

Зафиксировать техническую архитектуру и ключевые системы прототипа/вертикального среза игры «Магический гардероб» (web + mobile), чтобы:

- снизить неопределённость реализации;
- разложить игру на независимые подсистемы;
- определить данные/события/сохранения;
- задать масштаб вертикального среза.

---

## 1. Платформа, движок, ограничения

### 1.1 Платформы (цель)

- Web (desktop + mobile browser)
- Mobile: Android (приоритет) + iOS (если понадобится)

### 1.2 Движок

- **Godot 4.5+**
- Язык: **GDScript** (для скорости итераций и совместимости с web; C# в Godot 4 не экспортируется в Web, поэтому не используем его даже “чуть-чуть”).

### 1.3 Экспорт и ранняя проверка платформ

- Web export (WASM/WebGL2) проверяется с первого дня проекта.
- Тестовые билды: локально + хостинг (itch/GH Pages/любой static).
- Режим: по умолчанию собираем Web в single-thread варианте (без SharedArrayBuffer / COOP-COEP) ради совместимости с itch/web publisher’ами; при необходимости multi-thread требуется отдельная настройка.

### 1.4 Целевые технические ограничения

- 60 FPS на среднем мобильном устройстве.
- Время загрузки сцены: < 3 сек.
- Минимизировать размер web-билда: атласы, сжатие, ограничение аудио.
- Сохранение: локально (FileAccess + `user://`; для Web — виртуальная FS браузера, **персистенция не гарантирована**: зависит от IndexedDB/cookies, приватного режима, встраивания в iframe). В коде нужно проверять `OS.is_userfs_persistent()` и учитывать риск, что данные не переживут закрытие вкладки.

---

## 2. Архитектурный обзор

### 2.1 Принцип

**Симуляция отделена от представления.**

- Симуляция хранит состояние и правила.
- UI/анимации только визуализируют и отправляют команды.

### 2.2 Слои

1. **Core Simulation** (детерминированная логика)
	- тайм-менеджмент смены/волны;
	- очередь клиентов;
	- объекты гардероба (крючки/слоты/номерки/одежда);
	- состояния клиентов и удовлетворённость.
2. **Presentation**
	- сцены, анимации, VFX, звук;
	- подсветки, визуальные подсказки, UI.
3. **Meta / Progression**
	- сводка смены;
	- модификаторы между волнами;
	- экономика и расходы;
	- инструменты (отвёртка, магниты, магия).
4. **Persistence & Debug**
	- сохранения прогресса;
	- лог причин/событий (для сводки и отладки);
	- debug overlay.

### 2.3 Godot-скелет: сцены и Autoload

#### Autoload (Single Script Singletons)

- **RunManager**: смена/волны/модификаторы/переходы экранов.
- **ContentDB**: загрузка конфигов (Resources/JSON) и выдача по ключам.
- **SaveManager**: сохранение/загрузка меты и (опционально) текущего забега.
- **EventBus** (опционально): централизованные сигналы событий.

#### Основные сцены

- `Main.tscn` (root) → держит навигацию UI/экранов.
- `WardrobeScene.tscn` (игровая сцена смены).
- `ShiftSummary.tscn` (сводка смены).
- `ModifierSelect.tscn` (выбор модификатора между волнами).

---

## 3. Данные и сущности

### 3.1 Представление данных (data-driven)

Рекомендовано использовать **Resources** (быстрее и удобнее, чем чистый JSON) и/или JSON для контент-паков.

Ресурсы:

- `ClientArchetypeRes` (базовое терпение, payout, особенности).
- `WaveConfigRes` (пул клиентов, частота, сложность).
- `ModifierCardRes` (эффекты между волнами).
- `ZoneConfigRes` (свет/тень/карантин).
- `ItemRuleRes` (порча/износ).
- Общие параметры одежды: `ghost_interaction_blocked_when_lit: bool` (по умолчанию true), `ghost_visibility_alpha_when_lit: float` (0..1, рекомендуемый диапазон 0.5–0.8, дефолт TBD), `light_rule: String` (`NONE` | `DAMAGE` | `INTERACT_BLOCK`), `proximity_rule: String` (`NONE` | `INFECT`), `zombie_infect_radius: int`, `zombie_infect_rate: float`, `vampire_light_damage_rate: float`, пороги `condition_threshold_warning`, `condition_threshold_ruined`.
- Hydra-конфиги: `bundle_min_items`, `bundle_max_items`, `bundle_patience_multiplier`, `bundle_wrong_item_penalty_multiplier`, `magic_cost_multiplier_per_bundle_item`.
- Строковые значения правил (например, `light_rule`, `proximity_rule`) хранятся в данных ради удобства редактирования, но в коде сразу преобразуются в enum/константы; неизвестные значения приводятся к `NONE` с логом.
- Свойства правил в Item могут храниться как кэш или `rule_id` на конфиг; источником истины остаётся соответствующий ресурс (аркетип/правило).

### 3.2 Модель сущностей (логическая)

> Важно: на уровне симуляции это **данные**, а на уровне сцены — **узлы**, которые подписаны на обновления.

#### Player

- `pos: Vector2`
- `carry: Array[ItemRef]` (для вертикального среза: max = 2)
- `tool: ToolType` (None/Screwdriver/etc.)

#### Hook

- `hook_id: int`
- `zone: ZoneType` (Normal/Dark/Quarantine/Light)
- `slots: Array[ItemRef]` (для среза: 2)

#### Item

- `item_id: String`
- `kind: ItemKind` (Clothing/Ticket)
- `ticket_number: int` (владелец)
- `condition: float 0..100`
- `flags: Bitmask/Dictionary` (infectious, light_sensitive, invisible_far, …)
- `ghost_interaction_blocked_when_lit: bool` (конфигурируемый флаг для призрачных предметов)
- `ghost_visibility_alpha_when_lit: float` (0..1, визуальный намёк без UI-индикаторов; рекомендуемый диапазон 0.5–0.8, дефолт TBD ∼0.7)
- `status_tags: Array[String]` (временные статусы: `spoiled`, `blocked`, `quarantined`)
- `proximity_rule: String` (`NONE` | `INFECT`)
- `light_rule: String` (`NONE` | `DAMAGE` | `INTERACT_BLOCK`)
- `bundle_id: String` (для наборов гидры; внутренний идентификатор)
- `bundle_size: int` (количество предметов в наборе; можно хранить в запросе клиента)

#### Ticket

- `ticket_number: int`
- `role: TicketRole` (ClientTicket/AnchorTicket)
- `anchored: bool` (прикручен/откручен)
- `durability: float 0..100` (если включаем износ)

#### Client

- `client_id: String`
- `archetype: ArchetypeType` (Human/Zombie/Vampire/Ghost/Werewolf/Hydra)
- `state: ClientState` (Arriving/WaitingDrop/Inside/Returning/WaitingPick/Leaving/Gone)
- `patience: float 0..100`
- `ticket_number: int`
- `items: Array[ItemRef]` (в срезе обычно 1)
- `vip: bool`

#### WardrobeRunState

- `shift_index, wave_index`
- `time_elapsed, time_remaining`
- `queue: Array[ClientRef]`
- `money_earned, penalties`
- `cleanliness_or_entropy: float`
- `inspector_risk: float`
- `magic_resource: int` (страховка)
- `shift_payout_debt: int` (аварийный поиск вычитает из итога)
- `links: Dictionary[ticket_number -> linkData]` (страховки)
- `magic_config: Dictionary` (`insurance_mode`, `emergency_cost_mode`, лимиты/стоимости)
- `inspection_config: Dictionary` (расписание инспекций, эмуляция в MVP)

---

## 4. State Machines и игровой тайм

### 4.1 FSM игры (RunManager)

- `MainMenu`
- `ShiftInProgress`
	- `WaveIntro`
	- `WaveActive`
	- `WaveOutro → ModifierSelect`
- `ShiftSummary`
- `RunEnd`

### 4.2 FSM клиента

- Arriving → WaitingToDrop → Inside
- Returning → WaitingToPick → Leaving → Gone

### 4.3 Тайм

- Один “игровой тик” = `_process(delta)` или фиксированная симуляция в `_physics_process(delta)`.
- Рекомендуемо: **фиксированная симуляция** (physics) для стабильности и повторяемости.

---

## 5. Событийная модель (Godot Signals)

Вариант A (рекомендуемый для скорости):

- Узлы сцены общаются через **сигналы** и прямые вызовы сервисов RunManager/Simulation.

Вариант B (для масштабирования):

- Autoload `EventBus` публикует глобальные сигналы.

Базовые события:

- `client_arrived(client)`
- `dropoff_accepted(client)`
- `ticket_issued(client, ticket_number)`
- `item_placed(hook_id, slot_index, item)`
- `item_removed(hook_id, slot_index, item)`
- `pickup_requested(client)`
- `pickup_resolved(client, result)`
- `item_spoiled(item, reason)`
- `wave_ended(wave_index)`
- `shift_ended(summary)`
- `inspection_done(report)`

---

## 6. Подсистемы

### 6.1 SimulationCore

Ответственность:

- хранит `WardrobeRunState`;
- применяет команды игрока (`place/remove/swap/serve`);
- обновляет таймеры, очередь, терпение;
- генерирует события/лог причин.
- Технически реализуется как **чистый класс** (не Node): вызывается RunManager/WardrobeScene напрямую, что упрощает тестирование и перенос в другие среды.

Интерфейс (команды):

- `cmd_accept_dropoff(client_id)`
- `cmd_issue_ticket(client_id, ticket_number)`
- `cmd_place_item(hook_id, slot, item_ref)`
- `cmd_remove_item(hook_id, slot)`
- `cmd_swap(hook_a, slot_a, hook_b, slot_b)`
- `cmd_request_pickup(client_id)`
- `cmd_resolve_pickup(client_id, used_ticket_number)`

### 6.2 QueueSystem

- спавн клиентов по `WaveConfig`;
- поддержание очереди и состояний клиентов;
- tick терпения.

### 6.3 PlacementSystem

- операции place/remove/swap;
- принцип: “разрешаем многое, последствия потом”;
- выдаёт события для SpecialRules;
- перед каждым `pick/place/swap` проверяет ограничения архетипов (например, `ghost`): если `item.flags.has("ghost")` и слот, из которого берём или в который кладём, находится в свете (`is_slot_lit(source_slot/target_slot)`), возвращается причина для ShiftLog/Debug (не для UI игрока); реализация `is_slot_lit` может читать `hook.zone == Light` или обращаться к LightSystem.
- baseline-инварианты: `pick/place/swap` разрешены по умолчанию, блокировки вводятся только явными правилами; все операции логируют последствия (ShiftLog).
- Для правил света проверка `is_slot_lit(source_slot/target_slot)` применяется к слоту, из которого берём предмет, и/или к целевому слоту — Ghost трактуем как `INTERACT_BLOCK` (блокируем операции), Vampire — как `DAMAGE` (взаимодействие разрешено, но тик-процесс порчи запускается).

### 6.4 SpecialRulesSystem (архетипы)

Вертикальный срез:

- Zombie: порча соседних/в том же крючке.
- Vampire: порча на свету (зона).
- Baseline (Human): без особых ограничений; взаимодействия разрешены, пока не срабатывают внешние правила (зомби, свет и т.п.).

Расширение:

- Ghost (отложено):
	- Технические требования:
		- предмет видим, но `pick/place/swap` запрещены, если `is_lit == true`;
		- допустимый намёк: изменение альфы (`ghost_visibility_alpha_when_lit`), других предварительных подсказок нет;
		- блокировки фиксируются в ShiftLog; конфиг: `ghost_interaction_blocked_when_lit`, `ghost_visibility_alpha_when_lit`, `light_rule`.
	- UX намерение (может меняться): нет превентивных текстов/иконок; при попытке действия проигрывается краткий VFX/звук отказа (TBD).
- Werewolf: фазовый таймер.
- Hydra (multi-item наборы, отложено):
	- Технические требования:
		- Drop-off: набор из `bundle_size ≥ 2` предметов, общий `ticket_number`, уникальный `bundle_id` (невидимый игроку), хранится `bundle_size`.
		- Хранение без ограничений (разные крючки/слоты, swap разрешён).
		- Pick-up: обслуживание завершено, когда `returned_count == bundle_size`; частичная выдача допустима, но клиент ждёт.
		- Ошибки: неполный набор (`returned_count < bundle_size` → ожидание + падение терпения), чужой предмет (`bundle_id` mismatch → штраф + `reason=hydra_wrong_bundle`), повреждения считаются по стандартной схеме, но агрегируются по набору.
		- Магия: страховка/аварийка масштабирются по `bundle_size`.
	- UX намерение (может меняться): визуально показывать “стопку” на drop-off и индикатор прогресса (0/N) возле клиента; в сводке — сообщения “набор неполный”, “выдан чужой предмет”, “суммарная потеря звёзд −X”.

### 6.5 Satisfaction & Scoring

- перевод patience/ошибок/порчи в payout/penalty;
- пишет причины в `ShiftLog` (для объяснимости).

### 6.6 MagicSystem

MagicSystem — отдельный сервис симуляции, который принимает конфиг (Resource/JSON) с перечислением режимов. Числа, cooldown и лимиты — TBD и подбираются плейтестами, поэтому код обязан ссылаться на данные, а не на константы.

Параметры конфига:

- `insurance_mode`: `FREE` (поиск после страховки полностью бесплатен) или `SOFT_LIMIT` (условно бесплатен: лимит подсветок, cooldown, но не двойная оплата).
- `emergency_cost_mode`: `DEBT` (увеличиваем `shift_payout_debt`), `TIPS` (режем только бонусы/чаевые) или `SHIFT_CASH` (списываем из “кошелька смены”, если такой введём).
- `search_effect`: `REVEAL_SLOT` (подсвечиваем хук/слот), дополнительно presentation-режимы могут подсвечивать путь.
- `prices/limits`: значения стоимости страховки, лимитов поисков и т.д. в одном месте; помечены как TBD.

Две способности:

1. **Insurance Link (страховка)**
	- тратит `magic_resource` (стоимость из конфига) и создаёт связь `ticket_number -> item_id(s)`;
	- цель — снизить когнитивный долг; дефолт для skeleton/MVP — `insurance_mode=FREE`, но конфиг позволяет переключиться на `SOFT_LIMIT`.
2. **Emergency Locate (аварийный поиск)**
	- платим ресурсом, связанным с выплатой за смену (см. `emergency_cost_mode`), поэтому запись события обязательно попадает в `ShiftLog`;
	- дефолт для MVP — `emergency_cost_mode=DEBT`, остальные варианты включаются данными без переписывания логики поиска.

Эффект поиска всегда информационный: подсветить текущий `hook_id/slot` (симуляция ничего не телепортирует). Presentation-уровень может дополнить это стрелкой/маркером.

### 6.7 AnchorSystem (отвёртка)

- второй номерок-якорь можно “открутить”;
- стоимость: **время** (первое не-мгновенное действие);
- состояние: `anchored=true/false`;
- поддержка “перемещаемых якорей” как внешней памяти игрока.

### 6.8 Inspection / Cleanliness (опционально)

InspectionSystem также управляется конфигом, числа TBD:

- `inspection_mode`: `PER_SHIFT` (отчёт/штраф после каждой смены) или `INTERVAL` (раз в `N` смен — параметр `inspection_interval`).
- `mvp_emulation`: bool — если включено, показываем “inspection-style report” каждую смену, но штрафы можем занулять.
- `thresholds`: таблица штрафов/похвал за чистоту (оставляем пустой до тестов).
- `logging`: любое начисление грязи пишет причину в `ShiftLog`.

Система накапливает `cleanliness_or_entropy` и `inspector_risk` от:

- зомби-инцидентов;
- перегруза крючков;
- открученных номерков;

В `WardrobeRunState` эти счётчики должны жить всегда (даже до полноценной инспекции), чтобы их можно было выводить в сводке и прокидывать в будущие подсистемы (магниты, ремонт). Режим A/B выбирается конфигом, без правки кода.

### 6.9 Modifiers (roguelite)

- между волнами выбор 1 из 3 `ModifierCardRes`;
- эффекты: усиление архетипов, бонус к магии, изменение зон, ускорение и т.п.

---

## 7. UI/UX (минимально для TDD)

### 7.1 HUD смены

- волна/таймер;
- деньги (текущие) + долг/срез бонуса;
- магия (страховка);
- очередь и индикаторы терпения.

### 7.2 Подсветки

- предмет в руках;
- допустимые слоты/цели;
- визуализация страховки (иконка/линк);
- аварийный поиск (подсветить хук/путь).
- Ghost: нет UI-подсказок; допускается только изменение альфы в свете + VFX отказа при попытке.

### 7.3 Сводка смены

- доходы/штрафы;
- “что пошло не так” по причинам (лог);
- состояние гардероба (грязь/износ).

### 7.4 Система отображения одежды (карточка предмета)

- Триггер: карточка появляется/обновляется, когда игрок держит одежду в руках; скрывается, когда руки пусты.
- Запрет на раскрытие идентичности: карточка не показывает номерок, имя клиента и любые явные идентификаторы владельца.
- Запрет на явные правила: карточка не содержит текстовых подсказок “как работает механика” (свет, зомби, призрак и т.д.); игрок узнаёт правила через взаимодействие/сводку.
- Структура: крупный спрайт текущей одежды, допускается композиция из нескольких слоёв (база + 1..N оверлеев статуса) и анимированные эффекты поверх (мерцание, частицы, пульсации) для передачи состояния без текста.
- Единственный числовой индикатор: звёздный рейтинг (с половинками) как интегральная “ценность сейчас” = функция (базовая ценность × текущее состояние); формула/пороги/числа TBD и конфигурируются данными.

---

## 8. Вертикальный срез (MVP)

### 8.1 Цель

Доказать, что core loop «сервис + организация + якоря/магия» создаёт интересные решения и ощущение агентности.

### 8.2 Включить

- 1 смена = 3 волны;
- архетипы: Human, Zombie, Vampire;
- 2 слота на крючке;
- второй номерок-якорь через отвёртку (время-стоимость);
- страховка и аварийный поиск (разные стоимости/валюты);
- MagicSystem по умолчанию использует `insurance_mode=FREE`, `emergency_cost_mode=DEBT`, но конфиг позволяет переключить режимы без правки кода;
- `cleanliness_or_entropy`/`inspector_risk` копятся всегда; MVP показывает inspection-style report в конце смены (штрафы можно отключить флагом конфига);
- выбор модификатора между волнами;
- сводка смены с объяснимыми причинами.

### 8.3 Отложить

- Werewolf (фазы);
- Hydra (multi-item);
- полная экономика износа всех номерков;
- инспекции раз в N смен (можно эмулировать как финальный отчёт смены).

---

## 9. Сохранения

### 9.1 Что сохраняем

- мета: деньги/апгрейды/разблоки/пул модификаторов;
- (опционально) mid-run: текущая смена/волна/состояние крючков.
- схема: два файла —
	- `user://save_meta.json` (всегда присутствует, содержит только мету);
	- `user://save_run.json` (опционально, описывает активный забег; может отсутствовать до реализации mid-run сохранений).

### 9.2 Формат

- Оба файла — JSON через `FileAccess`.
- Версионирование схемы: `save_version` + миграции.
- Web-особенности: `user://` опирается на IndexedDB; persistance зависит от `OS.is_userfs_persistent()` (cookie/iframe/private mode могут отключить сохранения, поэтому UX должен предупреждать и/или дублировать данные на сервере позже).

---

## 10. Риски и тесты

### 10.1 Риски

- «Налог на интерфейс»: аварийный поиск становится обязательным.
- Вырождение стратегии: всегда страховать всё / всегда жить в хаосе.
- Death spiral: грязь/штрафы/потеря крючков → неизбежный проигрыш.
- Web export: ввод/производительность/размер билда.

### 10.2 Быстрые тесты (плейтестовые)

- Игрок после сводки должен уметь объяснить: *что он сделал → почему это привело к штрафу*.
- 3 игрока должны найти 3 разных “рабочих” стиля.
- Ранний web smoke-test на телефоне после каждой крупной итерации.

---

## 11. План реализации (итерации)

1. **Project skeleton**: сцены + autoload + базовый HUD + web export pipeline — см. [Step 1 guide](steps/01_project_skeleton.md).
2. **Core loop**: очередь → принять → выдать номерок → повесить → вернуть.
3. **Placement**: 2 слота + swap + перенос предметов.
4. **Архетипы**: zombie/vampire + порча.
5. **Якоря**: отвёртка, “немгновенное действие”, перемещаемые якоря.
6. **Магия**: страховка + аварийный поиск + объяснимый лог.
7. **Волны**: 3 волны + выбор модификатора.
8. **Сводка**: причины + экономика смены.
9. (Опц.) **Грязь/инспекция**: как долгосрочный NDR-рычаг.
