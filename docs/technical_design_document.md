# Technical Design Document (Godot)

## 0. Цель документа

Зафиксировать техническую архитектуру и ключевые системы прототипа/вертикального среза игры «Магический гардероб» (web + mobile), чтобы:

- снизить неопределённость реализации;
- разложить игру на независимые подсистемы;
- определить данные/события/сохранения;
- задать масштаб вертикального среза.

---

## 1. Платформа, движок, ограничения

### 1.1 Платформы (цель)

- Web (desktop + mobile browser)
- Mobile: Android (приоритет) + iOS (если будет возможность)

### 1.2 Движок

- Godot 4.5 (stable)

### 1.3 Сборки

- Dev: editor + hot reload.
- Тестовые билды: локально + хостинг (itch/GH Pages/любой static).
- Режим: по умолчанию собираем Web в single-thread варианте (без потоков); при необходимости multi-thread требуется отдельная настройка.

### 1.4 Целевые технические ограничения

- 60 FPS на среднем мобильном устройстве.
- Время загрузки сцены: < 3 сек.
- Минимизировать размер web-билда: атласы, сжатие, ограничение аудио.
- Сохранение: локально (FileAccess + `user://`; для Web — виртуальная FS). Использовать `OS.is_web()` и учитывать риск, что данные не переживут закрытие вкладки.

---

## 2. Архитектурный обзор

### 2.1 Слои (repo mapping)

- `scripts/domain/` — чистые данные/правила/состояния, без Godot зависимостей.
- `scripts/app/` — orchestration: «склеивает» доменные системы, хранит run/shift state, таймеры, генерации и т.п.
- `scripts/ui/` — Godot сцены, адаптеры, визуалы, input.

### 2.2 SSOT

- SSOT по игре — доменные state + app state.
- UI — проекция состояния и исполнитель команд, но не «истина».

### 2.3 Потоки

- Input → UI adapter → `InteractionService`/`ShiftService` → результат → events → UI визуалы.
- Внутренние подсистемы (desk/queue) тоже излучают события через диспетчеры/адаптеры.

---

## 3. Данные и сущности

### 3.1 Item (предмет)

- `item_id` — уникальный id предмета.
- `item_kind` — тип (TICKET / COAT / ...).
- `client_id` — владелец.
- `bundle_id` — задел под Hydra (опционально).
- `tags/modifiers` — задел под архетипы/эффекты.

### 3.2 Client (клиент)

- `client_id`
- `client_def_id` (ссылка на data-driven конфиг клиента)
- `phase`: `DROP_OFF` / `PICK_UP` / `DONE`
- `coat_id` (ожидаемый coat для выдачи)
- `ticket_item` (ссылка на ticket item, если применяется)

### 3.3 Slot (слот)

- `slot_id` — уникальный id слота.
- `slot_item` — текущее содержимое.

---

## 4. State Machines и игровой тайм

### 4.1 Run/Shift

- `RunState`: общий прогресс.
- `ShiftState`: текущая смена.

### 4.2 Клиенты/очередь

- `ClientQueueState` + `ClientState` (phase).

---

## 5. Событийная модель (Godot Signals)

### 5.1 Общий принцип

- Домен формирует «события результата» (переезды предметов, принятие/отказ, списания и т.п.).
- UI слой подписывается на сигналы адаптеров и обновляет представление.

---

## 6. Подсистемы

### 6.1 Storage

- `WardrobeStorageState` регистрирует слоты и предметы.
- Слоты уникальны по `slot_id`.

### 6.2 Interaction

- `WardrobeInteractionService` строит команду (`PICK/PUT/SWAP`) и применяет её.
- Рука (hand_item) хранится в домене (в сервисе) как snapshot, UI держит только визуал.

### 6.3 Desk/Service Points

- `DeskServicePointSystem` назначает клиентов и формирует ожидаемый предмет на desk-слоте.
- `validate` при выдаче coat сверяет `coat_id`.

### 6.4 Shift/Log

- `ShiftService` ведёт экономику/итоги.
- `ShiftLog` пишет события/причины.
- `ShiftSummary` читает лог.

---

## 7. UI/UX (минимально для TDD)

### 7.1 HUD смены

- базовые индикаторы (v0): деньги, магия, долг;
- верхняя очередь (Queue HUD): ближайшие клиенты + остаток check-in/check-out + strikes, без терпения;
- волна/таймер — допускается как плейсхолдер до шага «Клиенты как UI».

### 7.2 Подсветки

- предмет в руках;
- допустимые слоты/цели;
- визуализация страховки (иконка/линк);
- аварийный поиск (подсветить хук/путь).
- Ghost: нет UI-подсказок; допускается только изменение альфы в свете + VFX отказа при попытке.

### 7.3 Сводка смены

- звёзды/рейтинг;
- доходы/штрафы;
- “что пошло не так” по причинам (лог);
- состояние гардероба (грязь/износ).

### 7.4 Система отображения одежды (карточка предмета)

- Триггер: карточка появляется/обновляется, когда игрок держит одежду в руках; скрывается, когда руки пусты.
- Запрет на раскрытие идентичности: карточка не показывает номерок, имя клиента и любые явные идентификаторы владельца.
- Запрет на явные правила: карточка не содержит текстовых подсказок о правилах (вампир, зомби, призрак и т.д.); игрок узнаёт правила через взаимодействие/сводку.
- Структура: крупный спрайт текущей одежды, допускается композиция из 2–3 “бейджей” (иконки), допускаются динамические эффекты (мерцание, частицы, пульсации) для передачи состояния без текста.
- Единственный числовой индикатор: звёздный рейтинг (с половинками) за состояние; формула/пороги/числа TBD и конфигурируются данными.

---

## 8. Вертикальный срез (MVP)

### 8.1 Цель

Доказать, что core loop «сервис + организация» даёт чувство **«я организовал»** и провоцирует решения в стиле «комедия ошибок» (Papers, Please-like), даже без сюжетной подачи.

### 8.2 Включить (MVP v0 = Step 4)

- **Один экран**: `Workdesk + Storage Hall` без персонажа; управление только drag-and-drop (мышь/тач).
- **Storage Hall**:
	- 2 столбца × 3 ряда **шкафов** (6 штук), визуально — вид спереди без перспективы;
	- «внутренности шкафа» = префаб-раскладка из `WardrobeSlot` (единый принцип: меняется только расположение слотов/декор);
	- слоты остаются совместимыми с текущей логикой: на одну «позицию» хранения по-прежнему приходится 2 слота (`*_SlotA` для TICKET и `*_SlotB` для COAT), чтобы не ломать Step 3.
- **Service Zone**:
	- N сервис-слотов (в MVP начать с 2, далее — параметр/апгрейд);
	- в каждом слоте есть `DeskServicePoint` (drop-zone) и минимальный UI-плейсхолдер под клиента/терпение (терпение может не тикать на этом шаге).
- **Правило выдачи**: клиент принимает только свою одежду (`client_id ↔ item_id`), чужую — reject + событие в `ShiftLog`.
- **Chameleon preview** при перетаскивании:
	- «в руке» предмет крупный;
	- при наведении на storage — превью сжимается заранее + подсветка целевого слота;
	- при наведении на service — превью снова крупное + валидность (ok/reject) подсветкой.
- **Инфраструктура смены** (как есть): `RunManager → ShiftService → ShiftSummary`, `ShiftLog` копит события/причины.

### 8.3 Отложить (после MVP v0)

- ходьба персонажа и proximity-интеракции (оставить как debug harness из Step 2);
- полноценные волны/таймеры терпения/анти-игнор (логика + UI);
- архетипы с деградацией (Zombie/Vampire/Ghost) и реальная связь с зонами света;
- инспекция/энтропия как реальные штрафы (можно пока оставлять как отчёт/метрики);
- Hydra (multi-item), Werewolf, экономика износа всех номерков.

---

## 9. Step 2 — Movement + Pick/Put/Swap Sandbox

### 9.1 Цель и рамки

- **Важно:** это **debug harness**, не «игровая сцена MVP». Нужен для быстрой проверки доменной логики pick/put/swap и регрессий.
- Один уровень-песочница без клиентов/таймера, где игрок ходит WASD и взаимодействует с ближайшим слотом по клавише `interact`.
- Поддерживаем три операции: `PICK` (рука пуста + слот занят), `PUT` (рука занята + слот пуст) и `SWAP` (рука занята + слот занят).
- Минимальный UI: HUD с текущим состоянием (деньги/магия/долг), кнопка “end shift”.

### 9.2 Детали реализации

- `WardrobePlayerController`: движение + hand socket.
- `WardrobeSlot`: хранилище `slot_id` и `slot_item`, методы `put_item/take_item`.
- `WardrobeInteractionService`: построение/применение команд.
- `WardrobeInteractionAdapter` (UI): выбор ближайшего слота (по distance), вызов interact, применение визуальных событий.

### 9.3 Почему оставляем

- быстрый регрессионный тест взаимодействия;
- позволяет дебажить домен без сложной сцены и без drag-and-drop.

---

## 10. Step 3 — Desk + Client Queue + Ticket/Coat Exchange (текущая реализация)

### 10.1 Что уже есть

- `DeskServicePointSystem` + доменные `DeskState`:
	- на сервис-слоте всегда «ожидаемый предмет» клиента (drop-off → COAT, pick-up → TICKET), предмет перемещается из storage в desk-slot;
	- валидация выдачи: COAT принимается только если `coat_id == client.coat_id`.
- `ClientQueueSystem` + `ClientQueueState` + доменные `ClientState`:
	- клиенты имеют фазу (`DROP_OFF` / `PICK_UP` / `DONE`) и назначение на service point.
- Event pipeline:
	- доменные события взаимодействия (`InteractionResult.events`) → `WardrobeInteractionEventAdapter` (signals) → визуалы/рука/слоты;
	- desk-события через `DeskEventDispatcher` → `WardrobeInteractionEventsAdapter` (спавн/удаление предметов на desk, смена клиента и т.д.).
- `WardrobeWorldSetupAdapter`:
	- собирает `WardrobeSlot` / `DeskServicePoint`, регистрирует их в `WardrobeStorageState`;
	- даёт Step 3 setup-адаптеру список ticket-слотов (по суффиксу `*_SlotA`) и функцию «положить instance в слот».
- `ShiftService`/`ShiftLog`/`ShiftSummary`: минимум для цикла «начал смену → поиграл → сводка».

### 10.2 Что НЕ сделано (ожидаемо)

- визуальная репрезентация клиентов (портрет/силуэт, очередь, терпение);
- «волны» и анти-игнор как геймплей;
- свет/архетипы, инспекция и экономика — в основном как задел/заглушки.

### 10.3 Ключевая совместимость для Step 4

Step 4 не должен ломать Step 3. Самое критичное:

- storage-слоты, которые считаются «ticket slots», определяются сейчас как `slot_id.ends_with("_SlotA")`;
- desk-слоты должны оставаться `DeskServicePoint.desk_slot_id` (по умолчанию `%s_Slot`).

---

## 11. Step 4 — Workdesk + Storage Hall (drag-and-drop, без персонажа)

### 11.1 Цель

Перенести core loop из «ходьбы и proximity» в **drag-and-drop** UX, чтобы освободить внимание игрока под решения (сервис/ошибки/комбинаторика) и не тратить MVP-время на «сочность перемещения».

### 11.2 Экран и зоны

- **Один экран**, две зоны:
	- верх: **Storage Hall**;
	- низ: **Service Zone** (N сервис-слотов).
- Персонажа нет. «Рука» — курсорный контейнер (`CursorHand`), который визуально следует за pointer.
- Storage Hall (композиция сцены):
	- шкафы сеткой **2×3** (2 столбца × 3 ряда);
	- слева отдельная колонка **штор**: открыто/закрыто (в будущем влияет на свет всей левой колонки шкафов);
	- справа колонка **ламп**: лампа на каждый ряд правой колонки (в будущем — локальный свет ряда).
	- На Step 4 свет — только визуальная переключаемая маска/оверлей; геймплейное влияние — позже.

### 11.3 Storage Hall: шкафы как префабы-раскладки

- Каждый шкаф — инстанс префаба-раскладки:
	- внешний спрайт/декор может меняться;
	- внутри — набор `WardrobeSlot` в фиксированных точках.
- **Единый принцип:** «раскладка» — это только расположение slot-узлов; логика хранения общая.
- Совместимость с Step 3:
	- «позиция хранения» по-прежнему состоит из пары слотов: `*_SlotA` (ticket) и `*_SlotB` (coat);
	- `slot_id` должен формироваться детерминированно от шкафа/позиции.

### 11.4 Drag-and-drop: mapping на текущий InteractionEngine

DnD не вводит новую доменную механику. Он только меняет способ выбора target-слота:

- **Drag start** (нажатие на слот с предметом):
	- выполнить `PICK` через существующий `WardrobeInteractionService` (hand ← item).
- **Drag hover**:
	- подсветить ближайший target-слот (snap);
	- применить chameleon preview (storage=small, service=big).
- **Drop** (release на target-слоте):
	- выполнить `PUT`/`SWAP` через существующий движок;
	- если действие отвергнуто → VFX reject, предмет остаётся в руке (hand не очищается).

### 11.5 Задел под архетипы

- На Step 4 допустимы только визуальные переключатели света.
- Логика деградации (Vampire/Zombie/Ghost) должна жить в домене/подсистемах и приходить в UI через события/снапшоты (отдельный шаг после стабилизации DnD).

---

## 12. Сохранения

### 12.1 Где храним

- `user://` (FileAccess).
- Для Web: учитывать, что storage может очищаться браузером.

### 12.2 Что сохраняем

- Run progression (день, апгрейды, метрики).
- Настройки/конфиги.

### 12.3 Что НЕ сохраняем в MVP

- Сложные replays, детальные логи.

---

## 13. Риски и тесты

### 13.1 Риски

- Расползание SSOT в UI (нельзя).
- Сломать совместимость slot_id и Step 3 setup.
- Слишком ранняя генерализация шкафов/архетипов → рост сложности.

### 13.2 Тесты

- Unit: доменные системы (queue/desk/interaction).
- Smoke: запуск сцены, start/end shift.
- Web smoke test: загрузка и базовое взаимодействие.

---

## 14. План реализации (итерации)

1. **Project skeleton** — сделано (см. [Step 1 guide](steps/01_project_skeleton.md)).
2. **Step 2 (debug harness)**: Movement + Pick/Put/Swap Sandbox — сделано (см. [Step 2 guide](steps/02_step2_sandbox.md)).
3. **Step 3**: Desk + Client Queue + Ticket/Coat Exchange — сделано (см. [Step 3 guide](steps/03_Ticket-Coat_Exchange.md)).
4. **Step 4 (текущий фокус)**: новая сцена `Workdesk + Storage Hall` (drag-and-drop, без персонажа) — см. [Step 4 guide](steps/04_Workdesk-Storage_DnD.md).
5. **Клиенты как UI**: силуэты/портреты, модель терпения (таймер или «сколько обслужено»), анти-игнор (обслужить X/Y).
6. **Архетипы + свет**: Zombie/Vampire/Ghost и привязка к зонам света (шторы/лампы) + прогресс-бары порчи.
7. **Волны + модификаторы**: 3 волны за смену, выбор модификатора между волнами.
8. **Якоря/магия/инспекция**: отвёртка/2-й якорь, страховка/аварийный поиск, инспекция/энтропия как долгосрочный рычаг.
9. **Сводка**: причины + экономика смены + метрики (ошибки/схитрил/риск).
